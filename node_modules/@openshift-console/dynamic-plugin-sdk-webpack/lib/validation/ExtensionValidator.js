"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionValidator = exports.findWebpackModules = exports.collectCodeRefData = void 0;
const _ = require("lodash");
const coderef_resolver_1 = require("../coderefs/coderef-resolver");
const object_1 = require("../utils/object");
const ValidationResult_1 = require("./ValidationResult");
const collectCodeRefData = (extensions) => extensions.reduce((acc, e, index) => {
    const data = { index, propToCodeRefValue: {} };
    object_1.deepForOwn(e.properties, coderef_resolver_1.isEncodedCodeRef, (ref, key) => {
        data.propToCodeRefValue[key] = ref.$codeRef;
    });
    if (!_.isEmpty(data.propToCodeRefValue)) {
        acc.push(data);
    }
    return acc;
}, []);
exports.collectCodeRefData = collectCodeRefData;
const findWebpackModules = (compilation, exposedModules) => {
    const webpackModules = Array.from(compilation.modules);
    return Object.keys(exposedModules).reduce((acc, moduleName) => {
        acc[moduleName] = webpackModules.find((m) => {
            const rawRequest = _.get(m, 'rawRequest') || _.get(m, 'rootModule.rawRequest');
            return exposedModules[moduleName] === rawRequest;
        });
        return acc;
    }, {});
};
exports.findWebpackModules = findWebpackModules;
class ExtensionValidator {
    constructor(description) {
        this.result = new ValidationResult_1.ValidationResult(description);
    }
    validate(compilation, extensions, exposedModules, dataVar = 'extensions') {
        const codeRefs = exports.collectCodeRefData(extensions);
        const webpackModules = exports.findWebpackModules(compilation, exposedModules);
        // Each exposed module must have at least one code reference
        Object.keys(exposedModules).forEach((moduleName) => {
            const moduleReferenced = codeRefs.some((data) => Object.values(data.propToCodeRefValue).some((value) => {
                const [parsedModuleName] = coderef_resolver_1.parseEncodedCodeRefValue(value);
                return parsedModuleName && moduleName === parsedModuleName;
            }));
            if (!moduleReferenced) {
                this.result.addError(`Exposed module '${moduleName}' is not referenced by any extension`);
            }
        });
        // Each code reference must point to a valid webpack module export
        codeRefs.forEach((data) => {
            Object.entries(data.propToCodeRefValue).forEach(([propName, codeRefValue]) => {
                const [moduleName, exportName] = coderef_resolver_1.parseEncodedCodeRefValue(codeRefValue);
                const errorTrace = `in ${dataVar}[${data.index}] property '${propName}'`;
                if (!moduleName || !exportName) {
                    this.result.addError(`Invalid code reference '${codeRefValue}' ${errorTrace}`);
                    return;
                }
                const foundModule = webpackModules[moduleName];
                if (!foundModule) {
                    this.result.addError(`Invalid module '${moduleName}' ${errorTrace}`);
                    return;
                }
                const moduleExports = compilation.moduleGraph.getProvidedExports(foundModule);
                const exportValid = Array.isArray(moduleExports) && moduleExports.includes(exportName);
                if (!exportValid) {
                    this.result.addError(`Invalid module export '${exportName}' ${errorTrace}`);
                }
            });
        });
        return this.result;
    }
}
exports.ExtensionValidator = ExtensionValidator;
//# sourceMappingURL=ExtensionValidator.js.map